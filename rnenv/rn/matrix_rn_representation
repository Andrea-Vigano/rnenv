=====================
Representation theory
=====================

Real numbers are represented as a matrix with a widely different level of complexity.

RN -> [num data]
      [den data]

num data and den data are supposed to be lists of the units that compose num and den:

num = 2+√3 -> [2, √3] is num data

so:

(3)/(4-4√5) -> [3,   0  ]
                [4, -4√4]

If num data and den data have a different size we have to append zeros to the shorter list to make them match
Obviously, the units that compose num and den can be integers but also other RNs, making it possible to represent
any real number imaginable.

# TODO set up a mask to permit a more intuitive object initialization than the matrix creation one

num and den also are stored as a matrix:

den -> [ 4, 0, 0]
       [-4, 4, 2]

where the columns represent: coefficient, radicand, and index
each one of this values can be either an integer or another RN as well

simplification is done assuming that every possible RN nested in the main matrix has already been initialized and
reduced.
First of all num and den are reduced separately following the same procedures.

# TODO set up reducer following the guidelines here specified

-> UNIT SIMPLIFICATION:
First every line of the unit-matrix is simplified
    -> if integer: pass (cannot be reduced by itself)
    -> if RN (define from its classification)
        -> integer -> merge to matrix and parse as normal line
        -> fraction -> pass (cannot be reduced by itself) and compare to index
        -> simple root -> merge to matrix and parse as normal line
        -> any other class -> pass (should already be reduced as much as possible) and compare to index
        -> if double root -> parse for special cases and simplify if possible
    -> if root: parse as normal line
        -> factorize radicand and index
        -> compare factorizations (stored as a dict [factor: exponent])
        # TODO set up / get integer complex comparison functions (like are_coprimes)
        -> simplify
Then the unit is simplified as a single item
    -> merge integers
    -> merge equal roots (same index and same radicand)

-> FINAL SIMPLIFICATION
get num and den local GCD and compare them
-> if there is a compatibility, divide every each unit for a common factor (division must have already been set up)


================================
INIT specs and parameters nature
================================

init method of RN class should get num and den as 3 x N matrices (a mask is intended to be set up for an easier
instantiation procedure), containing integers and possibly other RNs

>>> a = RN(num=[[2, 0, 0], [3, 5, 2]], den=[[4, 3, 2]], index=2)

represent a complex RN like

√[(2 + 3√5)/(4√3)]

this object could be passed as argument of another real number instantiation, like:

>>> b = RN(num=[[a, 0, 0]], den=[[1, 0, 0]], index=3)

b should end up being

[6]√[(2 + 3√5)/(4√3)]

after all the reduction process.

This kind of approach is meant to be able to create a very elastic object, able to handle in the most simple way
possible the complex structures in which real numbers can come with.

======
-> a RN object can be represented as a 3 dimensional array like 2 x N x 3 where
2 -> num and den
N -> number of units that build up num and den
3 -> coefficient, radicand and index for each unit

RN -> stored in [[[coefficient, radicand, index] * N] -> num, [[coefficient, radicand, index] * N] -> den]
where the actual values are C, R, I, which can either be integers or other RNs

(will use numpy.array)
======


==========
MASK specs
==========

The 'mask' should enable a more intuitive instantiation procedure, by eliminating as much as possible the matrices
usage at the top level.
For instance, creating a RN like 2√2 should not be as complex as:

>>> RN(num=[[2, 0, 0]], den=[[1, 0, 0]], index=2)

or

>>> RN(num=[[2, 2, 2]], den=[[1, 0, 0]], index=1)

(which is equivalent to the first expression)

but could be something more like:

>>> RN([2, 2, 2])

after parsing, everything should be stored in matrix form

==================
REDUCTION PROTOCOL
==================

RN reduction protocol.

loop trough array num and den: (2)
loop trough every unit in num / den: (N)
    UNIT PARSING
    reduce:
        a unit is an integers triad referring to different aspects of itself
        +-------------+----------+-------+
        |      0      |     1    |   2   |
        +-------------+----------+-------+
        | coefficient | radicand | index |
        +-------------+----------+-------+

        so depending of this numbers we'll have different parsing possibilities

        if every parameter is integer -> First level RN:

            =======================
            INTEGERS UNIT REDUCTION
            =======================
            -> if N = 0: return 0, 0, 0
            -> parse CE
                -> L = 0: ValueError
                -> L is even and M < 0: ValueError
                -> L < 0 and M = 0: Value Error
            -> Parse 'special types' (easy - fast parse)
                -> L = 1: N *= M, M = 1
                -> M = 1, -1: N *= M, M = 1
            -> Parse L and factorized M's exponents ot be primes
                (using mathfuncs.factorization / .gcd)
                -> if gcd (exponents, L) != 1:
                    -> divide exponents and L by gcd
            -> Parse to bring factors out of root
                loop trough factorized M:
                    -> if factor exponent is greater than index:
                        -> N *= factor ** (int division between exponent and L)
                        -> exponent = module between exponent and L
                        (this way we avoid having to loop multiple times trough factors to be sure
                        that parsing is complete, because we ensure that the factor moved out of the root
                        is the greater possible)
            -> re build M from parsed factorized (using a flag to track eventual sign)
            -> Parse 'special types' (easy - fast parse)
                -> L = 1: N *= M, M = 1
                -> M = 1, -1: N *= M, M = 1
            =======================

        else -> N level RN:
            ->

==============================
LINEAR UNITS MERGING ALGORITHM
==============================
    -> array manipulation

    assign new empty array
    arr = array([0, 0, 0])

    get unique values in cols 1 and 2 (second and third)
    -> unq_one = np.unique(linear[:, 1])
    -> unq_two = np.unique(linear[:, 2])

    nested loop uniques and get all the rows with same 1-2 elements
    for one in unq_one:
        for two in unq_two:
            s = np.sum(linear[np.logical_and(linear[:, 1] == one, linear[:, 2] == two)][:, 0])
            if s[0]:
                arr = np.vstack((arr, [s, one, two]))
    return reduced data array
    return arr[1:]
==============================
